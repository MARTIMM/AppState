#-------------------------------------------------------------------------------
# Documentation
#

=head1 NAME

AppState::Log - Module to do message logging and severity status handling

=head1 SYNOPSIS

  use AppState;
  use AppState::Ext::Meta_Constants;

  def_sts( 'C_MY_ERROR1', 'M_ERROR', 'My first error: %s');

  my $config_dir = 't/Log';
  my $app = AppState->instance;
  $app->initialize( config_dir => $config_dir
                , use_work_dir => 0
                , use_temp_dir => 0
                );
  $app->check_directories;

  my $log = $app->get_app_object('Log');
  $log->show_on_error(0);
  $log->add_tag('SYN');
  $log->write_start_message(0);
  $log->start_logging;
  $log->log_level($self->M_TRACE);

  # Log message with predefined code
  # Result something like 'Trace: 32, Log-pod.pl'
  #
  $log->log( $log->C_LOG_TRACE, [__LINE__ . ', ' . __FILE__]);

  # Log message with our own code
  # Result something like 'My first error: 32, Log-pod.pl'
  #
  $log->log( $log->C_MY_ERROR1, [__LINE__ . ', ' . __FILE__]);

=head1 DESCRIPTION

As assumed from the title above this module does not only handle logging but
also provides a way to handle those messages by storing the error in a status
object which can be checked later. Also the error can be send to clients who has
subscribed for it. The core method is write_log(). The rest is just controlling
the Log module. The module used to write log entries is Log::Log4perl.

To prevent log messages which get too long because of long module names, 3
letter tags are used for each module and can be set using add_tag(). The default
will be '---' so it is nessesary to use that function before writing a log
entry. When a stack is dumped however, modulenames are used. The log module
will have '=LG' as its tag.

An example of the logfile is shown here;

  --------------------------------------------------------------------------------
  Logging format can be one of the following 3 possibilities;
  1) date
  2) time tag line_number severity_code wrapped_message
  3) msec tag line_number severity_code wrapped_message

  Milliseconds are shown when date and time are not changing between logs

  A tag is a 3 letter code representing the logging module. This is set when
  calling add_tag().

  Severity code is a 2 letter code.
  First is i, w, e, t, d and f for info, warning, error, trace, debug or fatal
  respectively. The second letter is s and f for success or failure respectively.

  Uppercase letters mean that the log will be forced while otherwise the setting
  of loglevel would prevent it.
  --------------------------------------------------------------------------------

  ----------
  2014-08-10
  ----------
  14:09:06 =LG 0537 IS Logger initialized
       980 =LG 0448 IS Logging started. Log level set to 'ERROR'. Starting new log
       980 =LG 0164 IS Log level changed from 'ERROR' into 'TRACE'
       981 =LG 1027 is Tag 'MXT' added for module 'main'
       000 =LG 1027 is Tag '=CL' added for module
	      'AppState::Plugins::Feature::CommandLine'
       000 =PM 0395 is Object CommandLine created
  14:09:07 =CL 0092 is Option processing changed: bundling
       003 =CL 0245 is Options processed
       004 =PM 0402 is Object CommandLine retrieved
       004 =PM 0402 is Object ConfigManager retrieved

The top legend can be hidden by using write_start_message(0). Besides tags for
the log module, there are also the entries from the
AppState::Plugins::Feature::PluginManager (=PM) and the
AppState::Plugins::Feature::CommandLine(=CL) modules.

=head1 METHODS

=head2 do_append_log($bool)

Method to set 'append to log'. Can be changed before the logfile is opened.
After the log is opened, it has no meaning. Without argument it returns the
current setting. The default is 1.

=head2 do_flush_log($bool)

Method to set 'flushing to log'. Can be changed before the logfile is opened.
After the log is opened, it has no meaning. Without argument it returns the
current setting. The default is 0.

=head2 log_file($filename)

Method to set logfile name. Can be changed before the logfile is opened.
After the log is opened, it has no meaning. Without argument it returns the
current setting. The default will be the basename of the program with '.log'
extention and is located in directory Appstate->instance->config_dir(). See
L<AppState>.

=head2 nbr_log_tags

The number of tags set in the logging module.

=head2 get_log_tag($module_name)

Return the module tag string for the given module name.

=head2 has_log_tag($module_name)

Check to see if module has a tagname defined

=head2 get_tag_modules

Get the registered modulenames which have a tag defined.

=head2 get_tag_names

Get the registered tag names

=head2 log_level

Set the log level. The levels are like those used by Log::Log4perl and
are defined in AppState::Ext::Constants. These are methods and named
M_TRACE, M_DEBUG, M_INFO, M_WARN, M_WARNING, M_ERROR and M_FATAL in increasing
order. M_WARN and M_WARNING return the same codes. Every log entry is compared
to this log level and errors having lower status will not get logged. There
are some more rules but see write_log() for more information.

=head2 die_on_error($bool)

Control if the write_log() must end the program after handling the message with
an error status. Default is off. Returns the current value when no argument is
given.

=head2 die_on_fatal($bool)

Control if the write_log() must end the program after handling the message with
a fatal status. Default is on. Returns the current value when no argument is
given.

=head2 show_on_warning($bool)

Control if the write_log() must show a stack dump after handling the message
with a warning status. Default is off. Returns the current value when no
argument is given. See show_on_error() for an example stackdump.

=head2 show_on_error($bool)

Control if the write_log() must show a stack dump after handling the message
with a error status. Default is on. Returns the current value when no
argument is given. An example stackdump of a message with an error status.
This error (E) is forced to appear (F) and the caller was at line 65 in the
main package. the 3 letter tag '100' was set by this main package.

  100 0065 EF Error does not have an error code and/or severity code
      Stack dump;
      0065 main
      0234 Test::Builder
      0239 Test::Builder
      0239 Test::Builder
      0747 Test::More
      0066 main

=head2 show_on_fatal($bool)

Control if the write_log() must show a stack dump after handling the message
with a fatal status. Default is on. Returns the current value when no
argument is given. See show_on_error() for an example stackdump.

=head2 write_start_message($bool)

Control if a legend must be written at the start of the logfile. Default is 1.

=head2 clear_last_error

Initialize to a successful state

=head2 is_last_success

Test if status is successful

=head2 is_last_fail

Test if status is a failure

=head2 is_last_forced

Test if status is forced

=head2 get_last_message

Get the message from the last saved state object

=head2 get_last_error

Get the error from the last saved state object

=head2 get_last_severity

Get the severity from the last saved state object

=head2 get_last_eventcode

Get the eventcode from the last saved state object

=head2 get_sender_line_no

Get the line number from the last saved state object

=head2 get_sender_file

Get the filename from the last saved state object

=head2 get_sender_package

Get the package name from the last saved state object

=head2 start_logging

Start the log. From this moment the write_log will write to the log depending
on the log level and if message is forced to be written.

=head2 stop_logging

Stop writing to the log.

=head2 log( $error, $message_values, $call_level)

Log will process the error as a dualvar created by Scalar::Util::dualvar. It
must hold a status code and a message. The message is a sprintf() string in
which variables, whenever there are any, are substituted from $message_values.
$message_values is an array reference. $call_level is used to denote the proper
caller for the message. The default for $call_level is 0.

The module AppState::Ext::Meta_Constants has a function def_sts() to help
creating the dualvar status values. The module AppState::Ext::Constants has a
set of predefined codes defined.

The function returns undef or when error is processed due to log level and what
have you, it returns a status object of type AppState::Ext::Status. In many cases
it might be stored in the Log module and can be queried later.

An example use is shown below. There are two status messages, one trace status
and a fatal status. By default, fatal status messages will end the program after
logging the message and showing the stack.


  package MyMod;

  use Moose;
  extends qw(AppState::Ext::Constants);
  use AppState;
  use AppState::Ext::Meta_Constants;

  def_sts( 'C_FILEOPENED', 'M_TRACE', 'File %s opened');
  def_sts( 'C_PROGRAMFAILURE', 'M_FATAL', 'Failure, cannot continue');

  sub open_file
  {
    my( $self, $filename) = @_;

    my $log = AppState->instance->get_app_object('Log');
    open my $fh, '<', $filename or $log->log($self->C_PROGRAMFAILURE);
    $log->log( $self->C_FILEOPENED, [$filename]);
    ...
  }


=head1 PRIVATE METHODS

This is documentation for me only! Everything can change at any point in the
future and is only mentioned here to prevent users overwriting the methods by
accident.

=head2 _log_tag

Return the hash reference of the module tags table.

=head2 _set_log_tag( $module_name => $tag_name)

Method to set the modules tagname.

=head2 _logging_is_forced

Check to see if error has a forced bit enabled.

=head2 _force_log

Force logging of message independend of log_level

=head2 _normal_log

Logging is normal in respect to log_level. That is, not forced.

=head2 _is_logging

Check to see if logging is started or not.

=head2 _logging_on

Turn logging on. Done in start_logging().

=head2 _logging_off

Turn logging off. Done in stop_logging.

=head2 _logger_initialized

Check if logger is initialized.

=head2 _set_logger_initialized

Method start_logging() will somewhere turn C<logger_initialized> on.

=head2 _loggers

Get the loggers structure as a hash reference. There is only one logger defined
called 'AppState::Plugins::Feature::Log' and is defined by code constant
C_LOG_LOGGERNAME.

=head2 _set_layout($logger_name => $Log_Log4perl_logger)

Set the Log::Log4perl::Logger logger to the $logger_name.

=head2 _get_logger($logger_name)

Get the Log::Log4perl::Logger logger using the $logger_name.

=head2 _nbr_loggers

Get the number of defined loggers.

=head2 _get_loggers

Get all logger names.

=head2 _logger_layouts

Get the logger layouts structure as a hash reference. There are 4 logger layouts
defined and the purpose and keys are shown in a table.

  Key           Purpose              Layout Pattern
  
  log.startmsg  Show start message   '%m%n'
  log.date      Show date            '%n----------%n%d{yyyy-MM-dd}%n----------%n'
  log.time      Show time and status '%d{HH:mm:ss} %m%n'
  log.millisec  Show msec and status '     %d{SSS} %m{chomp}%n'

The message %m will always be <tag> <line number> <status codes> <log message>
except for the start message which is kind of an explanation or legend. See
the example log output above.

=head2 _set_layout($logger_layout_name => $Log_Log4perl_layout)

Set the layout using one of the keys shown above. The layout is created by

  Log::Log4perl::Layout::PatternLayout->new($pattern);

using a pattern also shown above in the table.

=head2 _get_layout($logger_layout_name)

Get the layout from the layout hash.

=head2 _nbr_layouts

Get the number of layouts

=head2 _get_layouts

Get all layout keys

=head2 _previousMsg($msg)

Save previous message. This is used to prevent repetion of the same message.
When it repeats it shows '--[Message repeated]--'.

=head2 _previousTime($time)

Save previous time. When the previous time is the same as the current time, the
log message will be prefixed with milliseconds. Otherwise it will show
hours:minutes:seconds.

=head2 _previousDate($date)

Save previous date. When previous date is not the same as the current date it
shows the start message followed by the date. Then it shows the time and message.

=head2 _previousMsgEq($bool)

When previous message has repeated itself twice, this is set to true. When set
no log will be done.

=head2 _lastError($status_object)

Status object is saved here so the log object can be queried for its values.
See also clear_last_error, is_last_success, is_last_fail, is_last_forced,
get_last_message, get_last_error, get_last_severity, get_last_eventcode,
get_sender_line_no, get_sender_file, get_sender_package

=head2 BUILD

Moose build function to initialize after creating attributes.

=head2 DEMOLISH

Cleanup before deleting the object

=head2 plugin_cleanup

Cleaning up the module by stopping log output and deleting subscribers.

=head2 _make_logger_objects

Create the Log::Log4perl and its pattern layouts.

=head2 _log_data_line

Write the date. When a start message is needed this will be written first.

=head2 _log_time_line( $msg, $forced)

Write the time and message depending on log level and if message is forced
to be written.

=head2 _log_message( $msg, $forced)

Write message depending on log level and if message is forced to be written.

=head2 _get_log_level_name($mask)

Convert the status from the mask into the name used by Log::Log4perl

=head2 _get_log_level_function_name

Find Log::Log4perl log level function name from severity code in status object

=head2 _get_start_msg

Get the start message/legend





=head1 STATUS CODES

Many status codes are forced messages which means that when the error level is
lower than the log_level(), they will still be processed. It is done because
one can always see what the logger processes when logging is turned on. Fatal
error status will kill the program unless die_on_fatal(0) is called first.

  C_LOG_LOGINIT       M_F_INFO     Log initialized
  C_LOG_LOGSTARTED    M_F_INFO     Logging started
  C_LOG_LOGSTOPPED    M_F_INFO     Logging stopprd
  C_LOG_TAGLBLINUSE   M_FATAL      Tag already in use by other module.
  C_LOG_TAGALRDYSET   M_FATAL      Calling module has already a tag set.
  C_LOG_LLVLCHANGED   M_F_INFO     Log level changed
  C_LOG_TAGADDED      M_F_INFO     Tag added for calling module
  C_LOG_NOERRCODE     M_F_ERROR    Error does not have a event or severity code
  C_LOG_NOMSG         M_F_ERROR    No message or empty message in error
  C_LOG_LOGALRINIT    M_F_WARNING  Log already initialized. Happens with append,
                                   flush and hide message legend changes.

=head1 PROGRAM CODES

  C_LOG_LOGGERNAME                 The name used to set/get the loggername from
                                   Log::Log4perl.

=head1 SEE ALSO


=head1 AUTHOR

Marcel Timmerman, E<lt>mt1957@gmail.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2013 by Marcel Timmerman

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.14.3 or,
at your option, any later version of Perl 5 you may have available.


=cut
